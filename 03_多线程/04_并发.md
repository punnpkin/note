# 1. 问题：

多个线程访问同一个资源，线程不安全，会导致数据紊乱

```java
public class TestThread implements Runnable{

    private int nums = 10;

    @Override
    public void run() {
        while (true){
            if(nums <= 0) break;
            System.out.println(Thread.currentThread().getName()+" 拿到了第："+nums--);
        }
    }

    public static void main(String[] args) {
        TestThread testThread = new TestThread();

        new Thread(testThread,"A").start();
        new Thread(testThread,"B").start();
        new Thread(testThread,"C").start();
    }
}
```

结果

```java
//        C 拿到了第：9
//        B 拿到了第：10
//        A 拿到了第：10
//        B 拿到了第：7
//        C 拿到了第：8
//        B 拿到了第：5
//        A 拿到了第：6
//        B 拿到了第：3
//        C 拿到了第：4
//        B 拿到了第：1
//        A 拿到了第：2
```

# 2. 同步

线程同步是一种**等待机制**，多个线程同时访问资源需要进入**等待池形成队列**

资源需要进行加**锁**

锁+队列解决冲突问题

问题：

1. 一个线程持有锁引起其它需要此锁的线程挂起
2. 多线程下，加锁、释放锁会引起上下文切换和调度延时，性能问题
3. 优先级搞的线程等待优先级低的线程释放锁，叫**性能倒置**

## 2.1 synchronized

synchronized是Java的一个**关键字**，它能够将**代码块(方法)锁起来**

```java
 public synchronized void test() {
        // doSomething
    }

```

synchronized是一种**互斥锁**

- **一次只能允许一个线程进入被锁住的代码块**

synchronized是一种**内置锁/监视器锁**

- Java中**每个对象**都有一个**内置锁(监视器,也可以理解成锁标记)**，而synchronized就是使用**对象的内置锁(监视器)**来将代码块(方法)锁定的！ (锁的是对象，但我们同步的是方法/代码块)

**synchronized**，通过使用内置锁，来实现对变量的同步操作，进而实现了对变量操作的**原子性和其他线程对变量的可见性**，从而确保了并发情况下的线程安全。

### 使用

synchronized一般我们用来修饰三种东西：

- 修饰普通方法 用的锁是**Java3y对象(内置锁)**

  ```java
  public class Java3y {
      // 修饰普通方法，此时用的锁是Java3y对象(内置锁)
      public synchronized void test() {
          // 关注公众号Java3y
          // doSomething
      }
  }
  ```

- 修饰代码块 用的锁是**Java3y对象(内置锁)**--->this

  ```java
  public class Java3y {
      public  void test() {
          // 修饰代码块，此时用的锁是Java3y对象(内置锁)--->this
          synchronized (this){
              // 关注公众号Java3y
              // doSomething
          }
      }
  }
  ```

- 修饰静态方法 获取到的是**类锁(类的字节码文件对象)**：Java3y.class

  ```java
  public class Java3y {
  
      // 修饰静态方法代码块，静态方法属于类方法，它属于这个类，获取到的锁是属于类的锁(类的字节码文件对象)-->Java3y.class
      public static  synchronized void test() {
  
          // 关注公众号Java3y
          // doSomething
      }
  }
  ```

### 对象锁和类锁

synchronized修饰**静态方法**获取的是类锁(类的字节码文件对象)，synchronized修饰普**通方法或代码块**获取的是对象锁。

**获取了类锁的线程和获取了对象锁的线程是不冲突的！**

**重入锁：**锁的持有者是**线程，**当有了子类实例对象的锁再访问父类时，可以再加锁

每个锁关联一个**线程持有者**和一个**计数器**。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。

当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。

而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。

当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。



### 释放锁

1. 当方法(代码块)执行完毕后会**自动释放锁**，不需要做任何的操作。
2. **当一个线程执行的代码出现异常时，其所持有的锁会自动释放**。

### 锁升级

锁的4中状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态（级别从低到高）

**自旋锁**：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务。

优点：

* 自旋锁不会使**线程状态**发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。

**偏向锁：**锁总是由同一个线程多次获得。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的**锁记录里存储锁偏向的线程ID**，偏向锁是一个可重入的锁。

**轻量级锁**：轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。

**重量级锁**：通过对象内部的监视器(monitor)实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实 现，操作系统实现线程之间的切换需要从**用户态到内核态**的切换，切换成本非常高。线程竞争不使用自旋，不会消耗CPU。但是线程会进入阻塞等待被其他线程被唤醒，响应时间缓慢。

![](04_并发.assets/2018032217003676)

### synchronized怎么做到有序性、可见性、原子性

#### 同步代码

通过javap -v 来查看对应代码的字节码指令，对于同步块的实现使用了monitorenter和monitorexit指令，他们隐式的执行了Lock和UnLock操作，用于提供原子性保证。 monitorenter指令插入到同步代码块开始的位置、monitorexit指令插入到同步代码块结束位置，jvm需要保证每个monitorenter都有一个monitorexit对应。

所有的互斥，其实在这里，就是看你能否获得monitor的所有权，一旦你成为owner就是获得者。

#### 同步方法

加了特殊标志位ACC_SYNCHRONIZED

同步方法的时候，一旦执行到这个方法，就会先判断是否有标志位，然后，ACC_SYNCHRONIZED会去隐式调用刚才的两个指令：monitorenter和monitorexit。

所以归根究底，还是monitor对象的争夺。



## 2.2 Lock

更加灵活的一种锁的方式，

需要手动释放的一种加锁方式

### 公平锁

公平锁理解起来非常简单：

- 线程将按照它们**发出请求的顺序来获取锁**

非公平锁就是：

- 线程发出请求的时可以**“插队”**获取锁

Lock和synchronized都是**默认使用非公平锁的**。如果不是必要的情况下，不要使用公平锁

- 公平锁会来带一些性能的消耗的

