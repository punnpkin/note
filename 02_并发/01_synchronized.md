# Synchronized

Java中的每一个对象都可以作为锁

- 对于普通同步方法，锁是当前实例对象
- 对于**静态**同步方法，锁是当前类的Class对象，类锁
- 对于同步方法块，所示Synchronized括号里配置的对象

JVM是如何实现锁：JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。

synchronized 有 `monitorenter` 和 `monitorexit` 两种指令来保证锁，而它们的作用可以理解为每个锁对象拥有一个锁计数器，也就是如果再次调用 lock() 方法，计数器会进行加 1 操作。

synchronized是一把重量级锁，会引起用户态内核态的切换



### 对象锁和类锁

synchronized修饰**静态方法**获取的是类锁(类的字节码文件对象)，synchronized修饰普**通方法或代码块**获取的是对象锁。

**获取了类锁的线程和获取了对象锁的线程是不冲突的！**

**重入锁：**锁的持有者是**线程，**当有了子类实例对象的锁再访问父类时，可以再加锁

每个锁关联一个**线程持有者**和一个**计数器**。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。

当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。

而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。

当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。

### 释放锁

1. 当方法(代码块)执行完毕后会**自动释放锁**，不需要做任何的操作。
2. **当一个线程执行的代码出现异常时，其所持有的锁会自动释放**。

### 锁升级

锁的4中状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态（级别从低到高）

**自旋锁**：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务。

优点：

* 自旋锁不会使**线程状态**发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快。

**偏向锁：**锁总是由同一个线程多次获得。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的**锁记录里存储锁偏向的线程ID**，偏向锁是一个可重入的锁。（所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁）

**轻量级锁**：轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。

**重量级锁**：通过对象内部的监视器(monitor)实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从**用户态到内核态**的切换，切换成本非常高。线程竞争不使用自旋，不会消耗CPU。但是线程会进入阻塞等待被其他线程被唤醒，响应时间缓慢。

![](01_synchronized.assets/2018032217003676)

### synchronized怎么做到有序性、可见性、原子性

#### 同步代码

通过javap -v 来查看对应代码的字节码指令，对于同步块的实现使用了monitorenter和monitorexit指令，他们隐式的执行了Lock和UnLock操作，用于提供原子性保证。 monitorenter指令插入到同步代码块开始的位置、monitorexit指令插入到同步代码块结束位置，jvm需要保证每个monitorenter都有一个monitorexit对应。

所有的互斥，其实在这里，就是看你能否获得monitor的所有权，一旦你成为owner就是获得者。

#### 同步方法

加了特殊标志位ACC_SYNCHRONIZED

同步方法的时候，一旦执行到这个方法，就会先判断是否有标志位，然后，ACC_SYNCHRONIZED会去隐式调用刚才的两个指令：monitorenter和monitorexit。

所以归根究底，还是monitor对象的争夺。