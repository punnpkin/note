# 02 垃圾收集器与内存分配策略

**程序计数器、虚拟机栈、本地方法栈**3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个**栈帧中分配多少内存基本上是在类结构**确定下来时就已知的。

**Java堆和方法区**这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。

## 2.1 对象已死

### 2.1.1 可达性分析

基本思路就是通过一系列称为**“GC Roots”**的**根对象**作为**起始节点集**，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为**“引用链”**（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

可作为**GC Roots**的对象包括：

* **栈中引用的对象**
* **方法区中类静态属性引用的对象**
* **方法区中常量引用的对象**
* **本地方法栈引用的对象**
* **Java虚拟机内部的引用**
* **同步锁（synchronized关键字）持有的对象**
* Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存
* 分代收集和局部回收（Partial GC）

### 2.1.2 引用

强引用（Strongly Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）

* **强引用：**垃圾收集器就永远不会回收掉被引用的对象，`Object obj = new Object()`
* **软引用：**有用，但非必须的对象。在内存溢出异常前，列入回收范围之中进行第二次回收
* **弱引用：**非必须对象，但是它的强度比软引用更弱一些，垃圾收集发生时就会回收
* **虚引用：**对象被收集器回收时收到一个系统通知，最弱的引用

### 2.1.3 对象死亡

要真正宣告一个对象死亡，至少要经历两次标记过程：

1. **第一次标记：**引用链不可达
2. **第二次标记：**判断此对象是否有必要执行finalize()方法
   * 对象没有覆盖finalize()方法
   * finalize()方法已经被虚拟机调用过

若有必要执行finalize()方法，且**在finalize()方法中重新引用到"GC  Roots"链上**

finalize()只会在对象内存回收前被**调用一次**

finalize()的调用具有**不确性**，只保证方法会调用，但不保证方法里的任务会被执行完（比如一个对象手脚不够利索，磨磨叽叽，还在自救的过程中，被杀死回收了）。

### 2.1.4 回收方法区

方法区的垃圾收集主要回收两部分内容：**废弃的常量和不再使用的类型**

## 2.2 垃圾收集算法

### 2.2.1 分代收集理论

分代假说：

1. 弱分代假说：绝大多数对象都是朝生夕灭的
2. 强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。

收集器应该将**Java堆**划分出不同的区域，然后将回收对象依据其**年龄**（年龄即对象熬过垃圾收集过程的次数）分配到**不同的区域**之中存储。

> 显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以**较低代价回收到大量的空间**；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。

3. 跨代引用假说：跨代引用相对于同代引用来说**仅占极少数**。

解决跨代引用的问题，**新生代会晋升到老年代**。

新生代上有一个全局的数据结构，标识出老年代的哪一块内存会存在跨代引用。

### 2.2.2 常见的算法

**1. 标记清除：**大量标记和清除的动作，内存空间的碎片化问题

**2. 标记复制：**内存用完的时候，就把存活着的对象复制到另外一块上面

> Appel式回收的具体做法是把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。
>
> HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。

用于新生代的垃圾回收

**3. 标记整理：**先标记对象，然后把存活的对象整理到内存的一边（可能造成停顿）