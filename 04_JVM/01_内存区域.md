# 01 Java内存区域

## 1.1 运行时数据区域

![这里写图片描述](01_内存区域.assets/20180711221632221)

**线程共享：**方法区 堆 

**线程隔离：**栈（虚拟机栈，本地方法栈）程序计数器，（**随线程而生，随线程而灭**）

1. **程序计数器**

   它可以看作是当前线程所执行的字节码的**行号指示器**

   为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器

2. **Java虚拟机栈**

   虚拟机栈描述的是Java方法执行的**线程内存模型**，每个方法被执行的时候，Java虚拟机都会同步创建一个**栈帧**用于存储局部变量表、操作数栈、动态连接、方法出口等信息。”栈”通常就是指这里讲的虚拟机栈。

   这里存储了**基本数据类型，对象引用和返回地址**

   * 当线程请求的栈深度大于虚拟机所允许的**深度**，将抛出StackOverflowError异常；

   * Java虚拟机栈容量可以动态扩展，当无法申请到足够的内存会抛出OutOfMemoryError异常。

3. **本地方法栈**

   虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

   > 简单地讲，一个Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现。

4. **堆**

   Java堆（Java Heap）是虚拟机所管理的内存中最大的一块，**被所有的线程共享**。

   此内存区域的**唯一目的**就是**存放对象实例**，所有的**对象实例以及数组**都应当在堆上分配。

   如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。

5. **方法区**

   **各个线程共享的内存区域**，用于存储已被虚拟机加载的**类型信息、常量、静态变量**，方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

6. **运行时常量池**

   运行时常量池（Runtime Constant Pool）是**方法区**的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是**常量池表（Constant Pool Table）**

## 1.2 虚拟机

### 1.2.1 对象的创建

new->类加载检查

-> 为新生对象分配内存（大小在类加载完后就可以完全确定，从Java堆中划分内存块）

* **指针碰撞：**假设内存连续，一种分界点指针，*需要保证原子性*
  * 失败重试法
  * 本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）：预先分配内存
* **空闲列表：**假设不连续，维护列表记录内存块

-> 内存空间初始化**零值**

-> 对象头设置（确定是哪个类的实例，元数据，哈希码）

虚拟机的工作已经结束，Java程序的的对象创建刚刚开始：

-> **构造函数**：Class文件中的`<init>()`方法

### 1.2.2 对象的内存布局

对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）

**对象头**

1. 存储对象**自身的运行时数据**，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。

2. 对象指向它的**类型元数据的指针**，Java虚拟机通过这个指针来确定该对象是哪个类的实例。（并不是所有）
3. 如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。

**实例数据**

对象真正存储的有效信息，

**对齐填充**

 8字节的整数倍

### 1.2.3 对象的访问定位

Java程序会通过**栈上的reference数据**来操作堆上的具体对象。主流的访问方式主要有使用句柄和直接指针两种：

* 句柄：reference->句柄池->对象实例数据（堆），对象类型数据（方法区）
* 指针：reference->（指针指向对象类型）对象实例数据（堆）->对象类型数据（方法区）

使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。